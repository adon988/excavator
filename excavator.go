package excavator

import (
	"crypto/sha256"
	"crypto/tls"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/gocolly/colly"
	"github.com/godcong/go-trait"
)

var log = trait.NewZapSugar()

const tmpFile = "tmp"

// Excavator ...
type Excavator struct {
	Workspace string `json:"workspace"`
	URL       string `json:"url"`
	HTML      string `json:"html"`
	Radicals  map[string]Radical
	header    http.Header
}

// Header ...
func (exc *Excavator) Header() http.Header {
	if exc.header == nil {
		return make(http.Header)
	}
	return exc.header
}

// SetHeader ...
func (exc *Excavator) SetHeader(header http.Header) {
	exc.header = header
}

// New ...
func New(url string, workspace string) *Excavator {
	log.With("url", url, "workspace", workspace).Info("init")
	return &Excavator{URL: url, Workspace: workspace}
}

// Run ...
func (exc *Excavator) Run() error {
	log.Info("excavator run")
	return exc.parseRadical()
}

func (exc *Excavator) parseRadical() (e error) {
	c := colly.NewCollector()
	c.OnHTML("a[href][data-action]", func(element *colly.HTMLElement) {
		da := element.Attr("data-action")
		log.With("value", da).Info("data action")
		if da == "" {
			return
		}
		r, e := exc.parseAJAX(exc.URL, strings.NewReader(fmt.Sprintf("wd=%s", da)))
		if e != nil {
			return
		}
		log.With("value", r).Info("radical")
	})
	c.OnResponse(func(response *colly.Response) {
		log.Info(string(response.Body))
	})
	c.OnRequest(func(r *colly.Request) {
		fmt.Println("Visiting", r.URL)
	})
	return c.Visit(exc.URL)
}

func (exc *Excavator) parseAJAX(url string, body io.Reader) (r *Radical, e error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}
	//body := strings.NewReader(`wd=%E4%B9%99`)
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.Header = exc.Header()

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return UnmarshalRadical(bytes)
}

//ParseDocument get the url result body
func (exc *Excavator) parseDocument(url string) (doc *goquery.Document, e error) {
	var reader io.Reader
	hash := SHA256(url)
	log.Infof("hash:%s,url:%s", hash, url)
	if !exc.IsExist(hash) {
		// Request the HTML page.
		res, err := http.Get(url)
		if err != nil {
			return nil, err
		}
		defer res.Body.Close()
		if res.StatusCode != 200 {
			return nil, fmt.Errorf("status code error: %d %s", res.StatusCode, res.Status)
		}
		reader = res.Body
		file, e := os.OpenFile(exc.getFilePath(hash), os.O_RDWR|os.O_CREATE|os.O_SYNC, os.ModePerm)
		if e != nil {
			return nil, e

		}
		written, e := io.Copy(file, reader)
		if e != nil {
			return nil, e
		}
		log.Infof("read %s | %d ", hash, written)
		_ = file.Close()
	}
	reader, e = os.Open(exc.getFilePath(hash))
	if e != nil {
		return nil, e
	}
	// Load the HTML document
	return goquery.NewDocumentFromReader(reader)
}

// IsExist ...
func (exc *Excavator) IsExist(name string) bool {
	_, e := os.Open(name)
	return e == nil || os.IsExist(e)
}

// GetPath ...
func (exc *Excavator) getFilePath(s string) string {
	if exc.Workspace == "" {
		exc.Workspace, _ = os.Getwd()
	}
	log.With("workspace", exc.Workspace, "temp", tmpFile, "file", s).Info("file path")
	return filepath.Join(exc.Workspace, tmpFile, s)
}

// SHA256 ...
func SHA256(s string) string {
	return fmt.Sprintf("%x", sha256.Sum256([]byte(s)))
}
